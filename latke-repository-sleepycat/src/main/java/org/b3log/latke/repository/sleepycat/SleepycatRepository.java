/*
 * Copyright (c) 2009, 2010, 2011, B3log Team
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.b3log.latke.repository.sleepycat;

import com.sleepycat.je.Cursor;
import com.sleepycat.je.CursorConfig;
import com.sleepycat.je.Database;
import com.sleepycat.je.DatabaseConfig;
import com.sleepycat.je.DatabaseEntry;
import com.sleepycat.je.LockMode;
import com.sleepycat.je.OperationStatus;
import com.sleepycat.je.TransactionConfig;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.b3log.latke.Keys;
import org.b3log.latke.repository.Query;
import org.b3log.latke.repository.Repository;
import org.b3log.latke.repository.RepositoryException;
import org.b3log.latke.util.Ids;
import org.json.JSONObject;

/**
 * Sleepycat repository.
 *
 * @author <a href="mailto:DL88250@gmail.com">Liang Ding</a>
 * @version 1.0.0.7, Sep 23, 2011
 */
public final class SleepycatRepository implements Repository {

    /**
     * Logger.
     */
    private static final Logger LOGGER =
            Logger.getLogger(SleepycatRepository.class.getName());
    /**
     * The current transaction.
     */
    public static final ThreadLocal<SleepycatTransaction> TX =
            new InheritableThreadLocal<SleepycatTransaction>();

    /**
     * Adds the specified json object.
     *
     * <p>
     *   The stored record looks like:
     *   <pre>
     *   key = {
     *     "oId": key
     *   }
     *   </pre>
     *   The key is generated by current time mills, and it will be used for
     *   database key entry sorting. If user need to update an certain json 
     *   object, just {@linkplain #remove(java.lang.String) removes} the old
     *   json object by key, and invoke this method to add the new json object
     *   which the value of "oId" as the same as the old one, the "oId" will
     *   NOT be generated because it exists.
     * </p>
     * @param jsonObject the specified json object
     * @return the generated object id
     * @throws RepositoryException repository exception
     * @see #update(java.lang.String, org.json.JSONObject)
     * @see Keys#OBJECT_ID
     */
    @Override
    public String add(final JSONObject jsonObject) throws RepositoryException {
        final SleepycatTransaction currentTransaction = TX.get();

        if (null == currentTransaction) {
            throw new RepositoryException("Invoking add() outside a transaction");
        }

        final String ret = Ids.genTimeMillisId();

        final Database database = Sleepycat.get(getName(), getDatabaseConfig());

        try {
            final DatabaseEntry entryKey = new DatabaseEntry(
                    ret.getBytes("UTF-8"));

            if (!jsonObject.has(Keys.OBJECT_ID)) {
                jsonObject.put(Keys.OBJECT_ID, ret);
            }

            final DatabaseEntry data = new DatabaseEntry(
                    jsonObject.toString().getBytes("UTF-8"));

            final OperationStatus operationStatus =
                    database.putNoOverwrite(
                    currentTransaction.getSleepycatTransaction(), entryKey, data);

            switch (operationStatus) {
                case KEYEXIST:
                    LOGGER.log(Level.SEVERE,
                               "Found a duplicated object[oId={0}] in repository[name={1}], ignores this add object operation",
                               new Object[]{ret, getName()});
                    throw new RepositoryException(
                            "Add an object into repository[name=" + getName()
                            + "] failed, caused by duplicated id[" + ret + "]");
                case SUCCESS:
                    LOGGER.log(Level.FINER,
                               "Added an object[oId={0}] in repository[name={1}]",
                               new Object[]{ret, getName()});
                    break;
                default:
                    throw new RepositoryException("Add an object[oId="
                                                  + ret + "] fail");
            }
        } catch (final Exception e) {
            LOGGER.log(Level.SEVERE, e.getMessage(), e);
            throw new RepositoryException(e);
        }

        return ret;
    }

    /**
     * Updates a certain json object by the specified id and the specified new
     * json object.
     *
     * <p>
     *   Update algorithm steps:
     *   <ol>
     *     <li>Finds the old record by the id stored in database value entry</li>
     *     O(n)
     *     <li>Removes the found old record if exists</li>
     *     <li>Sets id of the old one into the specified new json object</li>
     *     <li>Invokes {@linkplain #add(org.json.JSONObject) add} with the
     *         new json object as argument
     *     </li>
     *   </ol>
     * </p>
     *
     * <p>
     *   <b>Note</b>: the specified id is NOT the key of a database record, but
     *   the value of "oId" stored in database value entry of a record.
     * </p>
     *
     * @param id the specified id
     * @param jsonObject the specified new json object
     * @throws RepositoryException repository exception
     * @see Keys#OBJECT_ID
     */
    @Override
    public void update(final String id, final JSONObject jsonObject)
            throws RepositoryException {
        final SleepycatTransaction currentTransaction = TX.get();

        if (null == currentTransaction) {
            throw new RepositoryException(
                    "Invoking update() outside a transaction");
        }

        try {
            LOGGER.log(Level.FINER,
                       "Updating an object[oId={0}] in repository[name={1}]",
                       new Object[]{id, getName()});
            // Step 1, 2:
            remove(id);
            // Step 3:
            jsonObject.put(Keys.OBJECT_ID, id);
            // Step 4:
            add(jsonObject);
            LOGGER.log(Level.FINER,
                       "Updated an object[oId={0}] in repository[name={1}]",
                       new Object[]{id, getName()});
        } catch (final Exception e) {
            LOGGER.log(Level.SEVERE, e.getMessage(), e);
            throw new RepositoryException(e);
        }
    }

    /**
     * Removes a json object by the specified id.
     *
     * <p>
     *   <b>Note</b>: the specified id is NOT the key of a database record, but
     *   the value of "oId" stored in database value entry of a record.
     * </p>
     *
     * @param id the specified id
     * @throws RepositoryException repository exception
     * @see Keys#OBJECT_ID
     */
    @Override
    public void remove(final String id) throws RepositoryException {
        final SleepycatTransaction currentTransaction = TX.get();

        if (null == currentTransaction) {
            throw new RepositoryException(
                    "Invoking remove() outside a transaction");
        }

        final Database database = Sleepycat.get(getName(),
                                                getDatabaseConfig());
        final Cursor cursor = database.openCursor(currentTransaction.
                getSleepycatTransaction(), CursorConfig.DEFAULT);

        final DatabaseEntry foundKey = new DatabaseEntry();
        final DatabaseEntry foundData = new DatabaseEntry();

        try {
            while (cursor.getNext(foundKey, foundData, LockMode.DEFAULT)
                   == OperationStatus.SUCCESS) {
                final JSONObject jsonObject =
                        new JSONObject(new String(foundData.getData(), "UTF-8"));
                if (jsonObject.getString(Keys.OBJECT_ID).equals(id)) {
                    if (cursor.delete().equals(OperationStatus.SUCCESS)) {
                        LOGGER.log(Level.FINER,
                                   "Removed an object[oId={0}] from repository[name={1}]",
                                   new Object[]{id, getName()});
                    }

                    return;
                }
            }
        } catch (final Exception e) {
            LOGGER.log(Level.SEVERE, e.getMessage(), e);
            throw new RepositoryException(e);
        } finally {
            cursor.close();
        }

        LOGGER.log(Level.WARNING,
                   "Not found object[oId={0}] in repository[name={1}], ignores remove object operation",
                   new Object[]{id, getName()});
    }

    /**
     * Gets a json object by the specified id.
     *
     * <p>
     *   <b>Note</b>: the specified id is NOT the key of a database record, but
     *   the value of "oId" stored in database value entry of a record.
     * </p>
     *
     * @param id the specified id
     * @return a json object, {@code null} if not found
     * @throws RepositoryException repository exception
     * @see Keys#OBJECT_ID 
     */
    @Override
    public JSONObject get(final String id) throws RepositoryException {
        final Cursor cursor = Sleepycat.get(getName(),
                                            Sleepycat.DEFAULT_DB_CONFIG).
                openCursor(null, CursorConfig.DEFAULT);

        final DatabaseEntry foundKey = new DatabaseEntry();
        final DatabaseEntry foundData = new DatabaseEntry();

        try {
            while (cursor.getNext(foundKey, foundData, LockMode.DEFAULT)
                   == OperationStatus.SUCCESS) {
                final JSONObject ret =
                        new JSONObject(new String(foundData.getData(), "UTF-8"));
                if (ret.getString(Keys.OBJECT_ID).equals(id)) {
                    LOGGER.log(Level.FINER,
                               "Got an object[oId={0}] from repository[name={1}]",
                               new Object[]{id, getName()});

                    return ret;
                }
            }
        } catch (final Exception e) {
            LOGGER.log(Level.SEVERE, e.getMessage(), e);
            throw new RepositoryException(e);
        } finally {
            cursor.close();
        }

        LOGGER.log(Level.WARNING,
                   "Not found an object[oId={0}] in repository[name={1}]",
                   new Object[]{id, getName()});

        return null;
    }

    // TODO: @Override
//    public JSONObject get(final int currentPageNum,
//                          final int pageSize)
//            throws RepositoryException {
//        final Database database = Sleepycat.get(getName(),
//                                                getDatabaseConfig());
//        final Cursor cursor = database.openCursor(null, CursorConfig.DEFAULT);
//
//        final long count = database.count();
//        final int pageCount =
//                (int) Math.ceil((double) count / (double) pageSize);
//
//        final JSONObject ret = new JSONObject();
//
//        final DatabaseEntry foundKey = new DatabaseEntry();
//        final DatabaseEntry foundData = new DatabaseEntry();
//        try {
//            final JSONObject pagination = new JSONObject();
//            ret.put(Pagination.PAGINATION, pagination);
//
//            pagination.put(Pagination.PAGINATION_PAGE_COUNT, pageCount);
//            final int passCount = pageSize * (currentPageNum - 1);
//            int cnt = 0;
//            while (cnt < passCount) {
//                cursor.getNext(foundKey, foundData, LockMode.RMW);
//
//                cnt++;
//            }
//
//            cnt = 0;
//            final JSONArray resultList = new JSONArray();
//            ret.put("d", resultList);
//            while (cnt < pageSize
//                   && cursor.getNext(foundKey, foundData, LockMode.DEFAULT)
//                      == OperationStatus.SUCCESS) {
//                final JSONObject jsonObject =
//                        new JSONObject(new String(foundData.getData(), "UTF-8"));
//                resultList.put(jsonObject);
//
//                cnt++;
//            }
//
//            LOGGER.log(Level.FINER,
//                       "Found objects[size={0}] at page[currentPageNum={1}, pageSize={2}] in repository[{3}]",
//                       new Object[]{cnt,
//                                    currentPageNum,
//                                    pageSize,
//                                    getName()});
//        } catch (final Exception e) {
//            LOGGER.log(Level.SEVERE, e.getMessage(), e);
//            throw new RepositoryException(e);
//        } finally {
//            cursor.close();
//        }
//
//        return ret;
//    }
    @Override
    public List<JSONObject> getRandomly(final int fetchSize)
            throws RepositoryException {
        throw new UnsupportedOperationException("Not supported yet!");
    }

    @Override
    public long count() throws RepositoryException {
        throw new UnsupportedOperationException("Not supported yet!");
    }

    @Override
    public SleepycatTransaction beginTransaction() {
        SleepycatTransaction ret = TX.get();
        if (null != ret) {
            LOGGER.log(Level.FINER,
                       "There is a transaction[isActive={0}] in current thread",
                       ret.isActive());
            if (ret.isActive()) {
                return TX.get(); // Using 'the current transaction'
            }
        }

        final com.sleepycat.je.Transaction sleepycatTx =
                Sleepycat.ENV.beginTransaction(null, TransactionConfig.DEFAULT);

        ret = new SleepycatTransaction(sleepycatTx);
        TX.set(ret);

        return ret;
    }

    @Override
    public boolean has(final String id) throws RepositoryException {
        throw new UnsupportedOperationException("Not supported yet.");
    }

    @Override
    public JSONObject get(Query query) throws RepositoryException {
        throw new UnsupportedOperationException("Not supported yet.");
    }

    @Override
    public String getName() {
        throw new UnsupportedOperationException("Not supported yet.");
    }

    @Override
    public boolean isCacheEnabled() {
        throw new UnsupportedOperationException("Not supported yet.");
    }

    @Override
    public void setCacheEnabled(boolean isCacheEnabled) {
        throw new UnsupportedOperationException("Not supported yet.");
    }
}
